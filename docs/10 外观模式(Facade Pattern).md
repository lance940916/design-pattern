# 个人白话
对象结构性模式
侧重点：对内部复杂的调用提供统一的接口，降低系统与系统之间的耦合度。但是！不要试图通过外观类在子系统中增加新的行为。

# 1 模式动机
在现实生活中，常常存在办事较复杂的例子，如办房产证或注册一家公司，有时要同多个部门联系，这时要是有一个综合部门能解决一切手续问题就好了。

软件设计也是这样，当一个系统的功能越来越强，子系统会越来越多，客户对系统的访问也变得越来越复杂。这时如果系统内部发生改变，客户端也要跟着改变，这违背了“开闭原则”，也违背了“迪米特法则（最少知道原则）”，所以有必要为多个子系统提供一个统一的接口，从而降低系统的耦合度，这就是外观模式的目标。

# 2 模式定义
外观模式(Facade Pattern)：外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。**外观模式又称为门面模式**。

属于 **对象结构型模式**。

它是 **迪米特法则** 的典型应用。

# 3 模式结构
外观（Facade）模式包含以下主要角色：

- 外观（Facade）角色：为多个子系统对外提供一个共同的接口。
- 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。
- 客户（Client）角色：通过一个外观角色访问各个子系统的功能。

# 4 模式代码
```java
# 子系统角色
public class SubSystem01 {
    public void f01() {
        System.out.println("SubSystem01 f01");
    }
}
public class SubSystem02 {
    public void f02() {
        System.out.println("SubSystem02 f02");
    }
}
public class SubSystem03 {
    public void f03() {
        System.out.println("SubSystem03 f03");
    }
}

# 外观角色
public class Facade {
    private SubSystem01 system01 = new SubSystem01();
    private SubSystem02 system02 = new SubSystem02();
    private SubSystem03 system03 = new SubSystem03();

    public void f() {
        system01.f01();
        system02.f02();
        system03.f03();
    }
}

# 客户角色
public class Client {
    public static void main(String[] args) {
        // 不将每个子系统进行实例化，然后分别进行调用
        // 而是提供一个外观类，提供对子系统的统一调用。
        Facade facade = new Facade();
        facade.f();
    }
}
```

# 5 总结
**分析**

根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。 -外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。 - 外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。 -外观模式的目的在于降低系统的复杂程度。 -外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。

**优点**

- 对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易。通过引入外观模式，客户代码将变得很简单，与之关联的对象也很少。
- 实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可。
- 降低了大型软件系统中的编译依赖性，并简化了系统在不同平台之间的移植过程，因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。
- 只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类。

**缺点**

- 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。
- 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。

不要试图通过外观类在子系统中增加新的行为，在外观模式中，当增加或移除子系统时需要修改外观类，这违背了“开闭原则”。如果引入抽象外观类，则在一定程度上解决了该问题。

# 参考资料

- [图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/index.html)
- [Java设计模式](http://c.biancheng.net/view/1317.html)